## 基本原理

- 由某个软件库提供await和async函数，await传入Promise，返回值；async传入值返回promise
- 通过ASM将await转换为状态机代码：将方法的代码复制到状态机中，当执行await调用时，复制当时的操作数栈和本地变量表，将访问操作数和本地变量表的操作全部修改为对象属性的操作。异步任务完成后，回复操作数栈和本地变量表，执行后续的逻辑。

## 难点

- lambda表达式的转换，需理解lambda表达式如何查找到实际调用的方法
- try catch finally的转换，需理解异常表和finally的实现
- 发生异常时，调用栈的处理


## 困难

- 与线程操作相关的代码无法转换，例如锁、JUC包、线程静态方法
    解决方案：ASM分析出某个代码无法转换时，将async方法放在线程池执行
- 无法进行调试
    解决方案：IDE插件在编译时生成class，同时生成source map，调试时代理JVM的调试端口

## 锁的模拟
- 对每一块锁起来的代码进行编号
- 系统开辟一片内存区域，保存编号和对象的锁定关系，当需要锁定某个对象时，需要先设置编号和对象的锁定关系

但是此方法需要JVM本身支持

## 上下文传播
